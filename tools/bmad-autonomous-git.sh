#!/bin/bash
# BMAD v6 Autonomous Git Workflow System
# Prevents massive conflicts by continuous micro-commits

set -euo pipefail

# Configuration
MAX_FILES_PER_COMMIT=10
MAX_LINES_PER_COMMIT=500
BRANCH_PREFIX="bmad-auto"
MAIN_BRANCH="master"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "${BLUE}[BMAD-GIT]${NC} $1"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not in a git repository"
        exit 1
    fi
}

# Get current branch
get_current_branch() {
    git branch --show-current
}

# Check for uncommitted changes
has_changes() {
    ! git diff-index --quiet HEAD --
}

# Count dirty files
count_dirty_files() {
    git status --porcelain | wc -l
}

# Get dirty files list
get_dirty_files() {
    git status --porcelain | cut -c4-
}

# Create micro-commits
create_micro_commits() {
    local files=($(get_dirty_files))
    local total_files=${#files[@]}
    
    if [ $total_files -eq 0 ]; then
        success "No changes to commit"
        return 0
    fi
    
    log "Processing $total_files dirty files"
    
    # Group files into micro-commits
    local commit_count=0
    local current_batch=()
    
    for file in "${files[@]}"; do
        current_batch+=("$file")
        
        # Check if we should commit this batch
        if [ ${#current_batch[@]} -ge $MAX_FILES_PER_COMMIT ]; then
            commit_batch "${current_batch[@]}"
            current_batch=()
            ((commit_count++))
        fi
    done
    
    # Commit remaining files
    if [ ${#current_batch[@]} -gt 0 ]; then
        commit_batch "${current_batch[@]}"
        ((commit_count++))
    fi
    
    success "Created $commit_count micro-commits"
}

# Commit a batch of files
commit_batch() {
    local files=("$@")
    local category=$(categorize_files "${files[@]}")
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    
    # Stage files
    git add "${files[@]}"
    
    # Create commit message
    local commit_msg="bmad: $category changes ($timestamp)

Files modified:
$(printf '- %s\n' "${files[@]}")

Auto-generated by BMAD v6 Autonomous Git System"
    
    # Commit
    git commit -m "$commit_msg"
    log "Committed ${#files[@]} files: $category"
}

# Categorize files by type/purpose
categorize_files() {
    local files=("$@")
    local categories=()
    
    for file in "${files[@]}"; do
        case "$file" in
            *.py) categories+=("python") ;;
            *.js|*.ts|*.jsx|*.tsx) categories+=("frontend") ;;
            *.md) categories+=("docs") ;;
            *.yaml|*.yml) categories+=("config") ;;
            *.sql) categories+=("database") ;;
            *test*) categories+=("tests") ;;
            *) categories+=("misc") ;;
        esac
    done
    
    # Return most common category
    printf '%s\n' "${categories[@]}" | sort | uniq -c | sort -nr | head -1 | awk '{print $2}'
}

# Sync with remote
sync_with_remote() {
    local current_branch=$(get_current_branch)
    
    log "Syncing with remote origin/$current_branch"
    
    # Fetch latest changes
    git fetch origin
    
    # Check if remote branch exists
    if git show-ref --verify --quiet refs/remotes/origin/$current_branch; then
        # Try to rebase
        if git rebase origin/$current_branch; then
            success "Successfully rebased on origin/$current_branch"
        else
            warning "Rebase conflicts detected, attempting auto-resolution"
            auto_resolve_conflicts
        fi
    else
        log "Remote branch doesn't exist, will create on push"
    fi
}

# Auto-resolve simple conflicts
auto_resolve_conflicts() {
    local conflicted_files=$(git diff --name-only --diff-filter=U)
    
    if [ -z "$conflicted_files" ]; then
        success "No conflicts to resolve"
        return 0
    fi
    
    log "Auto-resolving conflicts in: $conflicted_files"
    
    # For each conflicted file, try automatic resolution
    while IFS= read -r file; do
        if [[ "$file" == *.md ]] || [[ "$file" == *.txt ]]; then
            # For documentation files, prefer incoming changes
            git checkout --theirs "$file"
            git add "$file"
            log "Resolved $file (accepted incoming changes)"
        elif [[ "$file" == *package*.json ]] || [[ "$file" == *requirements.txt ]]; then
            # For dependency files, merge both
            git checkout --ours "$file"
            git add "$file"
            log "Resolved $file (kept our dependencies)"
        else
            # For code files, manual resolution needed
            warning "Manual resolution needed for: $file"
            return 1
        fi
    done <<< "$conflicted_files"
    
    # Continue rebase
    git rebase --continue
    success "Auto-resolved all conflicts"
}

# Push changes
push_changes() {
    local current_branch=$(get_current_branch)
    
    log "Pushing changes to origin/$current_branch"
    
    if git push origin $current_branch; then
        success "Successfully pushed to origin/$current_branch"
    else
        warning "Push failed, attempting force push with lease"
        if git push --force-with-lease origin $current_branch; then
            success "Force push successful"
        else
            error "Push failed completely"
            return 1
        fi
    fi
}

# Main autonomous workflow
main() {
    log "Starting BMAD v6 Autonomous Git Workflow"
    
    check_git_repo
    
    local dirty_count=$(count_dirty_files)
    
    if [ $dirty_count -eq 0 ]; then
        success "Repository is clean, nothing to do"
        return 0
    fi
    
    log "Found $dirty_count dirty files"
    
    # If too many changes, create feature branch
    if [ $dirty_count -gt 50 ]; then
        local timestamp=$(date +"%Y%m%d_%H%M%S")
        local feature_branch="${BRANCH_PREFIX}-${timestamp}"
        
        warning "Too many changes ($dirty_count), creating feature branch: $feature_branch"
        git checkout -b $feature_branch
    fi
    
    # Create micro-commits
    create_micro_commits
    
    # Sync with remote
    sync_with_remote
    
    # Push changes
    push_changes
    
    success "BMAD v6 Autonomous Git Workflow completed successfully"
}

# Run if called directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
